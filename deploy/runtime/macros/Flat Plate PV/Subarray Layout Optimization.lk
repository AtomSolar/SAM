/*@

<br><br>
This macro helps the user determine the optimal subarray size, ground coverage ratio (GCR), and module tilt angle over an area of fixed dimensions. The array placement is optimized with respect to 3 main strategies:
<br><br> 
 
<ol>
<li> Maximizing Annual Energy Production (AEP)</li>
<li> Maximizing Net Present Value (NPV) of System</li>
<li> Maximizing Energy Yield (kWh/kW) of the System</li>
<li> Minimizing Levelized Cost of Electricity (cents/kWh)</li>
</ol>

<br><br> Once the simulation is completed, you will have the option of automatically updating your current subarray layout based on one of the 3 optimization strategies outlined above. Optimized values that are updated include: strings in parallel, tilt, GCR, and number of modules along bottom of row.


<br><br> 
<b>Warnings and Tips:</b> 
<ul>
	<li> For accurate results, ensure self-shading is enabled under the Shading and Layout page in the active case.
	<li><b> If optimizing a single subarray, the number of inverters recommended for each optimization strategy is only for that particular subarray and not the entire system. </b>
	<li> Ensure number of modules per string in any active subarray is greater than 0.
@*/
 
 
//Macro User Interface Widgets
//@ name=subarray_x;type=combo;label=Subarray to be optimized;value=Subarray 1,Subarray 2,Subarray 3,Subarray 4,All Active Subarrays;sel=0
//@ name=length;type=number;label=Enter the Length of Field or Rooftop (m):;value=35
//@ name=width;type=number;label=Enter the width of Field or Rooftop (m):;value=25
//@ name=max_gcr;type=number;label=Enter the maximum GCR:;value=1 
//@ name=min_gcr;type=number;label=Enter the minimum GCR(value cannot equal 0):;value=0.1 
//@ name=gcr_steps;type=number;label=Enter the increments you would like to iterate GCR over:;value=0.1
//@ name=max_tilt;type=number;label=Enter the maximum allowable (fixed) tilt angle (in Degrees):;value=90
//@ name=min_tilt;type=number;label=Enter the minimum allowable (fixed) tilt angle (in Degrees):;value=0
//@ name=tilt_steps;type=number;label=Enter the increments for tilt angle (in Degrees):;value=10
//@ name=dcac;type=number;label=Desired DC to AC Ratio:;value=1.20
//@ name=update_results;type=combo;label=Update subarray configuration in active case optimized for;value=Max AEP,Max NPV,Max Energy Yield,Min LCOE,Do Not Update;sel=4
//@ name=show_in_browser;type=combo;label=Open results summary in default browser?;value=Yes, No;sel=1 

// display warning if the macro is run outside of a case
if ( typeof(macro) == 'unknown' ) {
	msgbox('This macro must be run from within a case.');
	exit;
}

///////////////////////////////////**** USER DEFINED INPUTS ****///////////////////////////////////

//User Defined Inputs:
subarray_x = macro.subarray_x;				//Subarray to be optimized 
effective_length = macro.length;			//(Calculated Value) Actual length of the field that is available for placement of modules (m)
effective_width = macro.width;				//(Calculated Value) Actual width of the field that is available for placement of modules	(m)
area = effective_length * effective_width; 	//(Calculated Value) Total effective land area (in m^2)
max_gcr = macro.max_gcr;					//Allow the user to input max GCR
min_gcr = macro.min_gcr;					//Allow the user to input min GCR
gcr_steps = macro.gcr_steps;				//Allow the  user to input the increments of GCR they want to calculate over
max_tilt = macro.max_tilt;					//Allow the user to input max tilt angle
min_tilt = macro.min_tilt;					//Allow the user to input min tilt angel
tilt_steps = macro.tilt_steps;				//Allow the user the input the increments of tilt angle they want to calculate over
dcac = macro.dcac;							//Desired Dc to AC ratio 
update_results = macro.update_results;		//Update subarray layout optimized for 1 of the 3 strategies, or do not update at all

//Max number of subarrays allowed in SAM currently:
max_subarrays = 4;			//Change this number if SAM changes max number of subarrays allowed in a simulation

acreage = area*0.0002471;					//m^2 to acres conversion

//If the user wants to iterate over fixed GCR or tilt angle, and sets either of
//the two variables to 0, then change value to 1 to prevent infinite looping.
if(gcr_steps <= 0 ) gcr_steps = max_gcr;
if(tilt_steps <= 0) tilt_steps = max_tilt;

////////////////////////////////////////EXCEPTION HANDLING////////////////////////////////////////////////

//Check to see financial model selected (which determines name of NPV variable name):
fin_model = configuration();
finConfig = fin_model[1];

if(finConfig == 'Sale Leaseback' || finConfig == 'LCOE Calculator') {
	msgbox('Sorry, this macro does not currently support the ' + finConfig + ' model!');
	exit;
}
elseif(finConfig == 'None') {
	msgbox('Sorry, this macro does not currently support the No Financial model!');
	exit;
}

//Allowing the user to optimize NPV from Developer/investor/host perspective:
elseif(finConfig == 'Leveraged Partnership Flip' || finConfig == 'All Equity Partnership Flip') 
	stakeholder = choose_from_list([ 'Developer' , 'Investor' ] , "Optimize NPV of project from perspective of: " );

elseif(finConfig == 'Host Developer')	
	stakeholder = choose_from_list([ 'Host' , 'Developer' ] , "Optimize NPV of project from perspective of: " );
	
//Currently, Third Party financial config does not use LCOE in its calculations:
if(finConfig =='Third Party' && update_results == 'Min LCOE'){
	msgbox('Sorry, ' + finConfig + ' configuration does not calculate LCOE. You can still use this macro, without selecting the minimize LCOE optimization strategy.');
	exit;
}
	
//If single_subarray is false implies that the user chose to optimize 'All Active Subarrays'
single_subarray = false;
if(subarray_x != 'All Active Subarrays') single_subarray = true;

sub_number = real_array(subarray_x);
if(get('subarray'+to_string(sub_number[1])+'_enable') == 0) {
	msgbox("You are trying to optimize Subarray "+to_string(sub_number[1])+", which is currently disabled in the active case.");
	exit;
}
if(get('subarray'+to_string(sub_number[1])+'_modules_per_string') == 0) {
	msgbox("Subarray " + to_string(sub_number[1]) + " has 0 modules per string.");
	exit;
}
	
	
////////////////////////////////////////FUNCTION DECLARATIONS////////////////////////////////////////////////	

//This block contains declarations of all functions used in the rest of this script. 
	
//========================================================================================================================================================================================================================================================================
//Display estimated time this macro will take to complet (in MM:SS format):
function time_display(minute, second) {	

	if ( minute == 0 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 00:0" + second + " seconds to complete. Proceed?");
	elseif ( minute == 0 && (second / 10) > 1) 
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 00:" + second + " seconds to complete. Proceed?");
	elseif ( minute < 10 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 0" + minute + ":0" + second + " minute(s) to complete. Proceed?");
	elseif ( minute < 10 && (second / 10) > 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take 0" + minute + ":" + second + " minute(s) to complete. Proceed?");
	elseif ( minute > 10 && (second / 10) < 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take " + minute + ":0" + second + " minute(s) to complete. Proceed?");
	elseif ( minute > 10 && (second / 10) > 1)
		continue_macro = yesno("You are attempting to optimize entire system (all active subarrays). This will take " + minute + ":" + second + " minute(s) to complete. Proceed?");
	
	if (continue_macro == false) {
		outln("\n	Consider reducing iterations of GCR and Tilt angle, or optimize over a single subarray instead for a quicker simulation.");
		exit;
	}

}

//========================================================================================================================================================================================================================================================================

// format numbers comma thousands indicator, 2 decimal places
// note: will display integers with 2 decimals, e.g., display 3 as 3.00
function num_to_str( x , d )
{
	// only format x if it is a number
	if ( typeof(x) == 'number' )
	{
		
		if( ( d == 0) && (mod( round(x) , 10) == 0) )	
			str = round(x);
		else 
			str = sprintf('%.'+to_string(d)+',',x);			// This step converts a number (for d = 0) like 409.857 to 41 instead of 410. This if-else condition is a workaround that bug.

		arr = split(str,'.');
		if ( #arr > 1 )
			num_decs = strlen(to_string(arr[1]));
		else
			num_decs = 0;
		// if number has one or more decimal places less than the desired number	
		if ( #arr > 1 && num_decs < d)
		{
			for (i=0; i<d-num_decs; i++)
				str += '0';
		}
		// if number has no decimal places
		elseif ( #arr == 1 && d > 0 )
		{
			str += '.';
			for (i=0; i<d; i++)
				str += '0';
		}		
	}
	// if x is a string, return it
	elseif ( typeof(x) == 'string' )
		str = x;
	// if x is not a number or string, convert it to a string with no formatting	
	else	
		str = to_string( x );
	return str;
}

//========================================================================================================================================================================================================================================================================

//Function for storing module power

module_info = define () {

		module_model = get('module_model');
		module_power = 0;
		
		if (module_model == 0){
			module_power = get('spe_power');
		}
		elseif (module_model == 1){
			module_power = get('cec_p_mp_ref');
		}
		elseif (module_model == 2){
			module_power = get('6par_pmp');
		}
		elseif (module_model == 3){
			module_power = get('snl_ref_pmp');
		}
		elseif (module_model == 4){
			module_power = get('sd11par_Pmp0');
		}
		return module_power;
};

//========================================================================================================================================================================================================================================================================
//Get Max AC power per inverter in kW
inverter_info = define() {

	inverter_model = get('inverter_model');
	inverter_power = 0;
	
	if (inverter_model == 0) {
		inverter_power = get('inv_snl_paco')/1000;
		}
	elseif (inverter_model == 1) {
		inverter_power = get('inv_ds_paco')/1000;
		}
	elseif (inverter_model == 2) {
		inverter_power = get('inv_pd_paco')/1000;
		}
	elseif (inverter_model == 3) { 
		inverter_power = get('inv_cec_cg_paco')/1000;
		}
	return inverter_power;
};
	
//========================================================================================================================================================================================================================================================================

//function for calculating system size 
system_sizer = define(gcr) {
		
		module_power = module_info();
		
		module_area = get('module_area');
		set('subarray1_gcr', gcr);
		system_size = gcr*(area/module_area)*(module_power/1000) ;
		return system_size;
};


//========================================================================================================================================================================================================================================================================
//Function to calculate system NPV, regardless of financial configuration selected by the user (by accounting for the difference in variable 
//names used for storing NPV based on the financial config.):
function npv_getter (fin_config) {

		if(fin_config == 'Residential' || fin_config == 'Commercial' || fin_config == 'Third Party' )	
			return get('npv');
		
		elseif(fin_config == 'Host Developer' && stakeholder == 'Developer') 
			return get('project_return_aftertax_npv');
			
		elseif(fin_config == 'Host Developer' && stakeholder == 'Host') 
			return get('npv');
		
		elseif(fin_config == 'Single Owner')
			return get('project_return_aftertax_npv');
		
		elseif((fin_config == 'Leveraged Partnership Flip' || fin_config == 'All Equity Partnership Flip') && stakeholder == 'Developer') 
			return get('sponsor_aftertax_npv');
		
		elseif((fin_config == 'Leveraged Partnership Flip' || fin_config == 'All Equity Partnership Flip') && stakeholder == 'Investor') 
			return get('tax_investor_aftertax_npv');

}

//========================================================================================================================================================================================================================================================================
//Function to creat a striped table to display optimal system configuration, as well as its techno-economic results for all 4 optimization strategies:
function display_results(gcr, tilt, nmodx, nmody, nrows, row_spacing, total_modules, modules_per_string, 
						 string_in_parallel , num_inverters, aep, sys_size, npv, yield, lcoe) {	//total of 14 arguments
						 
	h = '<table width="100%">';
	h += '<tr>';
	h += '<td bgcolor = #DCDCDC>';
		h += '<table width="100%">';
		h += '<th>';
		h += 'Optimal Subarray Configuration:';
		h += '</th>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td > <b>GCR</b> </td>';
		h += '<td>' + num_to_str(gcr , 3) + '</td>' ;
		h += '</tr>';
		h += '<tr>';
		h += '<td > <b>Tilt Angle (in Degrees) </b></td>'; 
		h += '<td>'+ tilt + '</td>' ; 
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td > <b>Number of modules along bottom </b></td>'; 
		h += '<td>' + nmodx + ' modules</td>'; 
		h += '</tr>';
		h += '<tr>';
		h += '<td><b>Number of modules along side of each row</b> <i>(Note: This was set by the user in the active case)</i></td>' ;
		h += '<td>' + nmody + ' module(s)</td>';
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td ><b>Number of rows </b></td>';
		h += '<td>' + num_to_str(nrows , 1) + ' rows</td>'; 
		h += '</tr>';
		h += '<tr>';
		h += '<td ><b>Row spacing between successive rows </b></td>';
		h += '<td>' + num_to_str( row_spacing, 2 ) + ' m</td>';
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td ><b>Total number of modules in subarray </b></td>'; 
		h += '<td>' + total_modules + ' modules</td>';
		h += '</tr>';
		h += '<tr>';
		h += '<td><b>Modules per string in subarray</b> <i>(Note: This was set by the user in the active case)</i></td>'; 
		h += '<td>' + modules_per_string + ' modules</td>';
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td><b>Strings in parallel in subarray </b></td>';
		h += '<td>' + string_in_parallel + ' strings</td>';
		h += '</tr>';
		h += '<tr>';
		h += '<td><b>Number of inverters </b></td>'; 
		h += '<td>' + num_inverters + '</td>';
		h += '</tr>';
		h += '</table>';
	h += '</td>';
	h += '</tr>';
	h += '</table>';
	h += '<br><br>';
	
	h += '<table width = "60%">';
	h += '<tr>';
	h += '<td bgcolor = #DCDCDC>';
		h += '<table width="100%">';
		h += '<th style="text-align: right">';
		h += 'Techno-Economic Results:';
		h += '</th>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td><b>Annual Energy Production </b></td>'; 
		h += '<td>' + num_to_str(aep , 0) + ' kWh</td>';
		h += '</tr>';
		h += '<tr>';
		h += '<td><b>System Size </b></td>'; 
		h += '<td>' + num_to_str(sys_size , 0) + ' kW</td>';
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td><b>Net Present Value (NPV)  </b></td>'; 
		h += '<td>$' +num_to_str(npv , 0) + '</td>';
		h += '</tr>';
		h += '<tr>';
		h += '<td><b>Energy Yield </b></td>'; 
		h += '<td>' + num_to_str(yield , 1) + ' kWh/kW</td>';
		h += '</tr>';
		h += '<tr bgcolor = #FFFFFF>';
		h += '<td><b>Levelized Cost of Electricity (cents/kWh) </b></td>'; 
		h += '<td>' + num_to_str(lcoe , 2) + ' cents/kWh</td>';
		h += '</tr>';
		h += '</table>';
	h += '</td>';
	h += '</tr>';
	h += '</table>';
	
	return h;
}

//========================================================================================================================================================================================================================================================================

//Function to display a table of results obtained for each combination of GCR and Tilt angle:
function display_table(min_gcr, max_gcr, gcr_steps, min_tilt, max_tilt, tilt_steps, array, dictionary, strategy) {	//strategy parameter checks if table is for LCOE -> in which case increase number of significant digits
	h = '<table>'; 
	h += '<table border = "1";  align = "center">';
	h += '<th> </th>';
	for (tilt = min_tilt  ; tilt <= max_tilt ; tilt = tilt + tilt_steps)
	{
		h += '<th bgcolor = #f2f2f2>Tilt Angle: ' + tilt + '</th>';
	}

	i = 0;
	for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
		j = -1;
		h += '<tr>';
		h += '<th bgcolor = #f2f2f2>GCR: ' + num_to_str( gcr , 3 ) + '</th>';
		for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {
			j = j + 1;
			if (array[i][j] == dictionary) h += '<td bgcolor = #00ff00>';
			elseif (array[i][j]  < 0) h += '<td bgcolor = #ff0000>';
			else h += '<td>';
			if (strategy == true)
				h += ' ' + num_to_str(array[i][j] , 3) + ' '; 
			else
				h += ' ' + num_to_str(array[i][j] , 0) + ' ';
			h += '</td>';
		}
		i = i + 1;
		h += '</tr>'; 
	}
	h += '</table>';
	return h;
}

//========================================================================================================================================================================================================================================================================
//Display green highlighted cell below results table (to display maximum/minimum value)
function table_key(key) {
	h = '<table  align = "center">';
	h += '<tr>'; 
	h += '<td bgcolor = #00ff00>';
	h += '<font size="2">' + key + '</font>';
	h += '</tr>'; 
	h += '</table>';
	return h;
}

//========================================================================================================================================================================================================================================================================
//Defining colors for curves (with a maximum limit of 90 curves per graph):
clr = ['#FF0000',	'#00FFFF',	'#FF00FF',	'#0000A0',	'#9ACD32',	'#800080',	'#FFFF00',	'#00FF00',	'#0000FF',	'#C0C0C0',	'#808080',	
	   '#000000',	'#FFA500',	'#A52A2A',	'#800000',	'#008000',	'#F08080', 	'#90EE90',	'#FFB6C1',	'#FFA07A',	'#20B2AA',	'#87CEFA',	
	   '#778899',	'#778899',	'#FFFFE0',	'#00FF00',	'#32CD32',	'#FAF0E6',	'#FF00FF',	'#800000',	'#66CDAA',	'#0000CD',	'#BA55D3',	
	   '#9370DB',	'#3CB371',	'#7B68EE',	'#00FA9A',	'#48D1CC',	'#C71585',	'#191970',	'#F5FFFA',	'#FFE4E1',	'#FFE4B5',	'#FFDEAD',	
	   '#000080',	'#FDF5E6',	'#808000',	'#6B8E23',	'#FFA500',	'#FF4500',	'#DA70D6',	'#EEE8AA',	'#98FB98',	'#AFEEEE',	'#DB7093',	
	   '#FFEFD5',	'#FFDAB9',	'#CD853F',	'#FFC0CB',	'#DDA0DD',	'#B0E0E6',	'#800080',	'#663399',	'#FF0000',	'#BC8F8F',	'#4169E1',	
	   '#8B4513',	'#FA8072',	'#F4A460',	'#2E8B57',	'#FFF5EE',	'#A0522D',	'#C0C0C0',	'#87CEEB',	'#6A5ACD',	'#708090',	'#708090',	
	   '#FFFAFA',	'#00FF7F',	'#4682B4',	'#D2B48C',	'#008080',	'#D8BFD8',	'#FF6347',	'#40E0D0',	'#EE82EE',	'#F5DEB3', 	'#F5F5F5',	
	   '#FFFF00',	'#ADD8E6'];

//Create a plot with GCR on the y-axis and tilt angle on the x-axis:
function new_plot(array, clr, yaxis_title, graph_title, graph_name){
	newplot(true);
	for ( count = 0; count <= (#array - 1) ; count = count + 1) {
		plot(x, array[count],{series = num_to_str(type[count], 3), color = clr[count], size = 3});
		axis('x1', {'label' = "Tilt Angle "});
		axis('y1', {'label' = yaxis_title});
		plotopt({'legendpos'='right', 'export_graph' = true, 'coarse'=true, 'fine'=true, 'title' = graph_title + " at Various GCR [" + subarray_x + "]"});
	}
	f_path=cwd();
	f_name = graph_name;
	f = f_path + '/' + f_name  + '.png';
	ok = plotout( f , 'png'); // png, pdf, bmp, or jpg. Defaults to png if file type not given.
	if ( ok == false)
	{
		outln('Could not save the plot to ' + f);
		return null;

	}
	else
		return f;
}

	
///////////////////////////////////////////////Return Estimated Time to Complete Macro////////////////////////////////////////////////////////////////////////

//Keeping tab of all subarrays that the user enabled in the active case; and a reminder to re-enable subarray (if the subarray was enabled before the macro) after simulation is complete.

timer = 1;					//variable used in calculation of estimated time macro will take to finish
subarray_flag[0] = 1; 		//where subarray_flag[0] is subarray 1. 
count_sub = 1;

while(count_sub < max_subarrays){
	if(get('subarray'+ to_string(count_sub + 1) +'_enable') == 1) {
		timer += 1;
		subarray_flag[count_sub] = 1;
	}
	else
		subarray_flag[count_sub] = 0;
	count_sub += 1;
}

iter = 0;
while(iter < max_subarrays){	//Create a list of subarrays in SAM.
	subarray_list[iter] = 'Subarray ' + to_string(iter+1);
	iter += 1;
}

system_inverter_count = 0;	//Keeps count of the number of inverters the system needs (only used when user chooses to optimize all active subarrays).
continue_macro = true;	
time_simulation = 0;		

//The option to diplay total time only kicks in when user decides to simulate ALL active arrays:
if(subarray_x != 'All Active Subarrays') 
	outln("\n\tOptimizing Array Layout for given ranges of GCR and Tilt over area of " + num_to_str(acreage, 3) + " acres.");
else {
	//Calculate time taken for 1 simulation. 
	start_timer();
	simulate();
	time_simulation = (elapsed_time()/1000) * ((max_gcr - min_gcr)/gcr_steps) * ((max_tilt - min_tilt) / tilt_steps) * timer * (1/60);		//Formula to estimate total time macro will take to complete if user is optimizing all active subarrays.
	time_simulation_min = floor(time_simulation);
	time_simulation_sec = floor((time_simulation - time_simulation_min) * 60);
	//Function call to display formatted time (For instance, 4 minutes 25 seconds will be displayed as: 04:25 minutes):
	time_display(time_simulation_min, time_simulation_sec);
	
}


////////////////////////**** DETERMINING WHICH SUBARRAY IS TO BE OPTIMIZED AND STORING EXISTING USER INPUT VALUES ****////////////////////////////

subarray_to_optimize = 0;

//This while loop goes through every enabled subarray to find the optimum desgin.

while (subarray_to_optimize < max_subarrays) {			
	
		if( single_subarray != true && timer == 1) single_subarray = true;
		
		if(single_subarray != true) {
			while(subarray_flag[subarray_to_optimize] == 0 && subarray_to_optimize < (max_subarrays - 1)  ) subarray_to_optimize = subarray_to_optimize + 1;	//If Subarray x is disabled in the active case, jump to subarray(x+1) and check if it is disabled. If enabled, jump out of while loop and optimize this subarray.
				
			choice = subarray_to_optimize;
			subarray_x = subarray_list[choice]; //? choice ['Subarray 1', 'Subarray 2',... , 'Subarray <max>' ];
		}
	
		if( subarray_to_optimize == (max_subarrays - 1) && subarray_flag[max_subarrays - 1] == 0) break; 		//End macro at this point if and when final subarray is reached and it is disabled in active simulation.
		
		//If the user is optimizing all active subarrays, ask them to input the allotted area for each subarray:
		if(single_subarray != true) {
			length = in("Enter length (in m) of field or rooftop alloted for " + subarray_x +":");
			width = in("Enter width (in m) of field or rooftop alloted for " + subarray_x +":");
			effective_length = to_real(length);		//(Calculated Value) Actual length of the field that is available for placement of modules (m)
			effective_width = to_real(width);			//(Calculated Value) Actual width of the field that is available for placement of modules	(m)
			area = effective_length * effective_width; 	//(Calculated Value) Total effective land area (in m^2)
		}
		
		outln('\n\tOptimizing Subarray ' + (subarray_to_optimize + 1) + ' over an area of ' + area + ' m^2:' );
		
		//Store subarray 1's configuration information:
		subarray1_modules_per_string = get('subarray1_modules_per_string');
		subarray1_nstrings = get('subarray1_nstrings');
		subarray1_track_mode = get('subarray1_track_mode');
		subarray1_tilt = get('subarray1_tilt');
		subarray1_azimuth =	get('subarray1_azimuth');
		subarray1_gcr = get('subarray1_gcr');
		subarray1_shade_mode = get('subarray1_shade_mode');
		subarray1_mod_orient = get('subarray1_mod_orient');
		subarray1_nmody = get('subarray1_nmody');
		subarray1_nmodx = get('subarray1_nmodx');
		inverter_count = get('inverter_count');
		
		count = 0;
		while (count < max_subarrays){
			set('subarray' + to_string(count+1) + '_enable', 0);
			count += 1;
		}
		
		
		//iter = 1;
		//while( iter <= max_subarrays){
			sub_number = real_array(subarray_x);
			//Variables that stay constant throughout simulation
			set('subarray1_modules_per_string', get('subarray'+to_string(sub_number[1])+'_modules_per_string'));	
			set('subarray1_track_mode', get('subarray'+to_string(sub_number[1])+'_track_mode'));
			set('subarray1_azimuth', get('subarray'+to_string(sub_number[1])+'_azimuth'));
			set('subarray1_shade_mode', get('subarray'+to_string(sub_number[1])+'_shade_mode'));
			set('subarray1_mod_orient', get('subarray'+to_string(sub_number[1])+'_mod_orient'));
			set('subarray1_nmody', get('subarray'+to_string(sub_number[1])+'_nmody'));

			//disable all other subarrays but subarray #1 which now contains the user defined values of subarray(iter) that is being optimized currently:
			count = 1;
			while(count <= max_subarrays){
				set('subarray'+to_string(count+1)+'_enable', 0);
				count += 1;
			}
			//iter += 1;

		//}


		///////////////////////////////////**** DEFINING PLACEHOLDER VARIABLES ****///////////////////////////////////

		db{"max_energy"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = 0, "yield" = 0, "lcoe" = 99999}; 
		db{"max_npv"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = -9999999999, "yield" = 0, "lcoe" = 99999}; 
		db{"max_yield"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = 0, "yield" = 0, "lcoe" = 99999}; 
		db{"min_lcoe"} = {"energy" = 0, "gcr" = 0, "tilt" = 0, "system_size" = 0, "npv" = 0, "yield" = 0, "lcoe" = 99999};
		
		db{"maxEnergy_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		db{"npv_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		db{"yield_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		db{"lcoe_config"} = {"nmodx" = 0, "nrows" = 0, "row_spacing" = 0, "total_modules" = 0};
		
		nmody =  get('subarray1_nmody');	//Number of modules along side row stays constant throughout, and is set by the user in the active case.
		
		///////////////////////////////////**** ARRAY PLACEMENT ****///////////////////////////////////

		i = 0;	
		//Loop over GCR to determine system size for each GCR, as well as determine number of modules required for each system size:
		for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
			module_power = module_info();
			system_size[i] = to_int(system_sizer(gcr));
			number_of_modules[i] = to_int(system_size[i]/(module_power/1000));
			i = i + 1;
		}

		if (get('subarray1_mod_orient') == 1) {					//if module orientation is landscape, then length of panel is used in calculating length of row
			module_length = get('module_length');				//Length of 1 module
			bottom_length = module_length;						//Initial length of bottom row of modules 
			set('subarray1_nmodx', 1);
		}
		elseif (get('subarray1_mod_orient') == 0) { 			//If module orientation is portrait, then width of panel is used in calculation length of row		
			module_length = get('module_width');				//Length of 1 module
			bottom_length = module_length;						//Initial length of bottom row of modules 
			set('subarray1_nmodx', 1);
		}


		p = 0;
		n = 0;		//number of panels along side bottom of row
		i = 0;
		//For loop to iterate over the entire range of (user input) GCRs, to make sure module placement along length and width of the field is 
		//in sync with the respective GCRs. So, for instance, even though the field length could accomodate a longer row of modules, number of modules 
		//in each row and alongside row is restricted to maintain GCR:	
		for(gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) {		//Fitting modules along length of field:				
			
			//Start by placing modules along effective lenght of field:	
			n = to_int((effective_length/module_length) );									
			set('subarray1_nmodx',n);
			
			//While loop to make sure number of modules along bottom row doesn't exceed system size at that GCR.
			while(get('subarray1_nmodx') < n){	
				n -= 1;
				set('subarray1_nmodx',n);
			}
			
			//Finding how many strings in parallel we need:
			strings_in_parallel[i] = to_int(number_of_modules[i] /get('subarray1_modules_per_string'));
			set('subarray1_nstrings', strings_in_parallel[i]);
			
			
			//If number of rows is less than 1, then take out modules from the bottom row till the number of rows is atleast 1
			while(get('ui_subarray1_nrows') < 1) {
				n = n - 1;
				set('subarray1_nmodx', n);
				
			}
			
			bottom_modules[p] = n;
			set('subarray1_nmodx', bottom_modules[p]);	
			
			p = p + 1;
			i = i + 1;
		}

		///////////////////////////////////**** S I M U L A T I O N ****///////////////////////////////////

		i = 0;
		progress_gcr = 0;	//Progress tracker

		//Nested for loop to calculate maximum AEP, maximum NPV, and max energy yield
		//for user input range of GCR and tilt angles
		for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 			//Loop for iterating over a range of GCR

			//Return what percent of the simulation is complete:
			if((max_gcr - min_gcr) != 0) {		//Skip showing progress if user is running simulation over one GCR value only
			progress = to_int((progress_gcr/(max_gcr - min_gcr)) * 100);
			progress_gcr += gcr_steps ;
			outln("\n\t[" + progress + "% complete] Currently simulating over GCR of: " + num_to_str(gcr , 3));
			}
			
			module_power = module_info() / 1000;		//divided by 1000 to get result in kW
			inverter_power = inverter_info();	//in kW
			j = -1;				//counter variable to keep tab of the columns in the loop
			
			//Setting desired system size:
			if(strings_in_parallel[i] == 0) strings_in_parallel[i] = 1;
			set_strings_in_parallel = strings_in_parallel[i];
			inverter_capacity_total = system_size[i] / dcac;
			num_inverters[i] = to_int(inverter_capacity_total / inverter_power);
			if(num_inverters[i] == 0) num_inverters[i] = 1;
			set('inverter_count', num_inverters[i]);
			set('subarray1_nstrings', to_int(set_strings_in_parallel));
			set('subarray1_gcr', gcr);
			set('subarray1_nmodx', bottom_modules[i]);
			num_rows[i] = get('ui_subarray1_nrows');
			
			for (tilt = min_tilt ; tilt <= max_tilt ; tilt = tilt + tilt_steps) {	//Loop for iterating over a range of tilt angles

				j = j + 1; 									//Variable to keep a tab of columns in the loop
				x[j] = min_tilt + (tilt_steps * j); 		//Array to store the tilt angles the user would like to iterate over
				set('subarray1_tilt', tilt);
				simulate();
				annual_energy[i][j] = get('annual_energy');
				npv[i][j] = npv_getter(finConfig);
				yield[i][j] = get('kwh_per_kw');
				lcoe[i][j] = get('lcoe_real');
				type[i] = gcr;
				
				//Storing the appropriate results (when calculating maximum AEP) in the respective placeholders
				if (annual_energy[i][j] > db{"max_energy"}.energy) {						
					db{"max_energy"}.energy = annual_energy[i][j] ;
					db{"max_energy"}.gcr = gcr;
					db{"max_energy"}.tilt = tilt;
					db{"max_energy"}.system_size = system_size[i];
					db{"max_energy"}.npv = get('npv');
					db{"max_energy"}.yield = yield[i][j];
					db{"max_energy"}.lcoe = lcoe[i][j];
					db{"maxEnergy_config"}.nmodx = get('subarray1_nmodx');
					db{"maxEnergy_config"}.nrows = get('ui_subarray1_nrows');
					db{"maxEnergy_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"maxEnergy_config"}.total_modules = get('total_modules');
					
					string_in_parallel_aep = get('subarray1_nstrings');
					modules_per_string_aep = get('subarray1_modules_per_string');
					inverter_aep = get('inverter_count');
				}
			//	outln(db{"max_npv"}.energy + '	' + npv[i][j]);		
				//Storing the appropriate results when calculating maximum NPV in the respective placeholders
				if (db{"max_npv"}.npv < npv[i][j]) {
					db{"max_npv"}.npv = npv[i][j];
					db{"max_npv"}.gcr = gcr; 
					db{"max_npv"}.tilt = tilt;
					db{"max_npv"}.system_size = system_size[i];
					db{"max_npv"}.energy = annual_energy[i][j];
					db{"max_npv"}.yield = yield[i][j];
					db{"max_npv"}.lcoe = lcoe[i][j];
					db{"npv_config"}.nmodx = get('subarray1_nmodx');
					db{"npv_config"}.nrows = get('ui_subarray1_nrows');
					db{"npv_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"npv_config"}.total_modules = get('total_modules');
					
					string_in_parallel_npv = get('subarray1_nstrings');
					modules_per_string_npv = get('subarray1_modules_per_string');
					inverter_npv = get('inverter_count');
				}
						
						
				//Storing the appropriate results when calculating maximum energy yield of project
				if (db{"max_yield"}.yield < yield[i][j]) {
				
					db{"max_yield"}.yield = yield[i][j];
					db{"max_yield"}.gcr = gcr;
					db{"max_yield"}.tilt = tilt;
					db{"max_yield"}.system_size = system_size[i];
					db{"max_yield"}.energy = annual_energy[i][j];
					db{"max_yield"}.npv = npv[i][j];
					db{"max_yield"}.lcoe = lcoe[i][j];
					db{"yield_config"}.nmodx = get('subarray1_nmodx');
					db{"yield_config"}.nrows = get('ui_subarray1_nrows');
					db{"yield_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"yield_config"}.total_modules = get('total_modules');
					
					string_in_parallel_yield = get('subarray1_nstrings');
					modules_per_string_yield = get('subarray1_modules_per_string');
					inverter_yield = get('inverter_count');
				}
				
				//Storing the appropriate results when calculating minimum LCOE:
				if (db{"min_lcoe"}.lcoe > lcoe[i][j]) {
				
					db{"min_lcoe"}.lcoe = lcoe[i][j];
					db{"min_lcoe"}.yield = yield[i][j];
					db{"min_lcoe"}.gcr = gcr;
					db{"min_lcoe"}.tilt = tilt;
					db{"min_lcoe"}.system_size = system_size[i];
					db{"min_lcoe"}.energy = annual_energy[i][j];
					db{"min_lcoe"}.npv = npv[i][j];
					db{"lcoe_config"}.nmodx = get('subarray1_nmodx');
					db{"lcoe_config"}.nrows = get('ui_subarray1_nrows');
					db{"lcoe_config"}.row_spacing = get('ui_subarray1_row_spacing');
					db{"lcoe_config"}.total_modules = get('total_modules');
					
					string_in_parallel_lcoe = get('subarray1_nstrings');
					modules_per_string_lcoe = get('subarray1_modules_per_string');
					inverter_lcoe = get('inverter_count');
				}
				
			}
			i = i + 1;		
		}


		///////////////////////**** REPOPULATING EXISTING USER INPUT VALUES AND OPTIMIZED VALUES IN SUBARRAY X IN ACTIVE CASE ****//////////////////////

		//Re-enable those subarrays that were enabled before the macro (but were not the subarray being optimized):
		count = 1;
		while(count < max_subarrays){
			if(subarray_flag[count] == 1) //Starting with subarray 2 since subarray 1 is always enabled
				set('subarray' + to_string(count+1) + '_enable', 1);
			count += 1;
		}

		if (subarray_x == 'Subarray '+to_string(sub_number[1])) {
			//Values that stay constant throughout simulation
			set('subarray'+to_string(sub_number[1])+'_modules_per_string', get('subarray1_modules_per_string'));	
			set('subarray'+to_string(sub_number[1])+'_track_mode', get('subarray1_track_mode'));
			set('subarray'+to_string(sub_number[1])+'_azimuth', get('subarray1_azimuth'));
			set('subarray'+to_string(sub_number[1])+'_shade_mode', get('subarray1_shade_mode'));
			set('subarray'+to_string(sub_number[1])+'_mod_orient', get('subarray1_mod_orient'));
			set('subarray'+to_string(sub_number[1])+'_nmody', get('subarray1_nmody'));
			
			//Updating optimized values based on user's selection
			if(update_results == 'Max AEP') {
				set('subarray'+to_string(sub_number[1])+'_nstrings', string_in_parallel_aep);
				set('subarray'+to_string(sub_number[1])+'_tilt', db{"max_energy"}.tilt);
				set('subarray'+to_string(sub_number[1])+'_gcr', db{"max_energy"}.gcr);
				set('subarray'+to_string(sub_number[1])+'_nmodx', db{"maxEnergy_config"}.nmodx);
				set('inverter_count', inverter_aep);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max NPV'){
				set('subarray'+to_string(sub_number[1])+'_nstrings', string_in_parallel_npv );
				set('subarray'+to_string(sub_number[1])+'_tilt', db{"max_npv"}.tilt);
				set('subarray'+to_string(sub_number[1])+'_gcr', db{"max_npv"}.gcr);
				set('subarray'+to_string(sub_number[1])+'_nmodx', db{"npv_config"}.nmodx );
				set('inverter_count', inverter_npv);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Max Energy Yield') {
				set('subarray'+to_string(sub_number[1])+'_nstrings', string_in_parallel_yield  );
				set('subarray'+to_string(sub_number[1])+'_tilt', db{"max_yield"}.tilt);
				set('subarray'+to_string(sub_number[1])+'_gcr', db{"max_yield"}.gcr);
				set('subarray'+to_string(sub_number[1])+'_nmodx', db{"yield_config"}.nmodx );
				set('inverter_count', inverter_yield);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
			elseif(update_results == 'Min LCOE') {
				set('subarray'+to_string(sub_number[1])+'_nstrings', string_in_parallel_lcoe  );
				set('subarray'+to_string(sub_number[1])+'_tilt', db{"min_lcoe"}.tilt);
				set('subarray'+to_string(sub_number[1])+'_gcr', db{"min_lcoe"}.gcr);
				set('subarray'+to_string(sub_number[1])+'_nmodx', db{"lcoe_config"}.nmodx );
				set('inverter_count', inverter_lcoe);
				system_inverter_count = system_inverter_count + get('inverter_count');
			}
		}


		//Reset values of subarray 1 (from before the macro was run):
		if(subarray_x != 'Subarray 1') {
			set('subarray1_modules_per_string',subarray1_modules_per_string);
			set('subarray1_nstrings', subarray1_nstrings);
			set('subarray1_track_mode', subarray1_track_mode);
			set('subarray1_tilt', subarray1_tilt);
			set('subarray1_azimuth', subarray1_azimuth);
			set('subarray1_gcr', subarray1_gcr);
			set('subarray1_shade_mode', subarray1_shade_mode);
			set('subarray1_mod_orient', subarray1_mod_orient);
			set('subarray1_nmody', subarray1_nmody);
			set('subarray1_nmodx', subarray1_nmodx);
			//set('inverter_count', inverter_count);
		}

		///////////////////////////////////**** R E S U L T S ****///////////////////////////////////
		
		str = '<html><body><h1><p align="center"> Summary of Results </p></h1>';
		
		str += '<br>Reported for case: <b>' + active_case() + '</b>';	
			
		if(single_subarray == true) {
			str += '<br>Showing results for: <b>' + subarray_x + '</b>';
			str += '<br><span  style="background-color: #FFFF00"><b>Note:</b> Optimal number of inverters reported are only for this particular subarray and not the entire system.</span>';
			//str += '<br><i>(If you are using this macro to optimize all active subarrays, note down the recommended number of inverters for this subarray. Once you have optimized all active subarray configurations, add all the recommended number of inverters for each subarray to give you the recommended number of inverters for the entire system.)</i>';
		}
		else {
			str += '<br>Showing results for: <b>'+ subarray_x + '</b>';
			set('inverter_count', system_inverter_count);
		}
		
		str += '<br><br>Given below is the subarray size at each iteration of GCR for total effective land/roof area of ' + round(area) + ' (m^2):';
		str += '';
		iter = 0;
		str += '<table>'; 
		str += '<table border = "1">';
		str += '<th bgcolor = #DCDCDC>GCR </th>';
		str += '<th bgcolor = #DCDCDC>Size (kW)</th>';
		
		for (gcr = min_gcr ; gcr <= max_gcr ; gcr = gcr + gcr_steps) { 
			str += '<tr>';
			//str += '<th>GCR: ' + num_to_str( gcr , 3) + '</th>';
			str += '<th>' + num_to_str( gcr , 3) + '</th>';
			str += '<td align="center">';
			str += '	' + system_size[iter] ;
			str += '</td>';
			iter = iter + 1;
			str += '</tr>'; 
		}
		str += '</table>';
		
		
		//Max AEP Results:
		str += '<br><h3 style="text-align: center">Results for Max Annual Energy Production (AEP): </h3>';
		str += display_results(db{"max_energy"}.gcr, db{"max_energy"}.tilt, db{"maxEnergy_config"}.nmodx, nmody, db{"maxEnergy_config"}.nrows, 
						db{"maxEnergy_config"}.row_spacing, db{"maxEnergy_config"}.total_modules, modules_per_string_aep, string_in_parallel_aep,
						inverter_aep, db{"max_energy"}.energy, db{"max_energy"}.system_size, db{"max_energy"}.npv, db{"max_energy"}.yield, db{"max_energy"}.lcoe);
						
		//Table for AEP Results
		strategy = false;	//checks if table is for fisplaying LCOE (which impacts number of significant digits to display on screen):
		str += '<br><p style="text-align: center"><strong>Table 1:</strong> AEP at Specified Combinations of GCR and Tilt Angles (kWH): </p>';
		str += display_table(min_gcr, max_gcr, gcr_steps, min_tilt, max_tilt, tilt_steps, annual_energy, db{"max_energy"}.energy, strategy);
		key = 'Max AEP';
		str += table_key(key);
		
		//Plot of AEP as a function of tilt angle (for various GCRs):
		yaxis_title = 'Annual Energy Production (kWh)';
		graph_title = 'Figure 1: Annual Energy Production';
		graph_name = 'max_aep';
		str += '<p style="text-align: center"><img src="'+new_plot(annual_energy, clr, yaxis_title, graph_title, graph_name) + '" /></p>';
		
		//Max NPV Results:
		str += '<br><br><h3  style="text-align: center">Results for Max NPV: </h3>';
		str += display_results(db{"max_npv"}.gcr, db{"max_npv"}.tilt, db{"npv_config"}.nmodx, nmody, db{"npv_config"}.nrows, 
						db{"npv_config"}.row_spacing, db{"npv_config"}.total_modules, modules_per_string_npv, string_in_parallel_npv,
						inverter_npv, db{"max_npv"}.energy, db{"max_npv"}.system_size, db{"max_npv"}.npv, db{"max_npv"}.yield, db{"max_npv"}.lcoe);
		
		//Table for NPV Results:
		strategy = false;	//checks if table is for fisplaying LCOE (which impacts number of significant digits to display on screen):
		str += '<br><p style="text-align: center"><strong>Table 2:</strong> NPV at Specified Combinations of GCR and Tilt Angles (in $): </p>';
		str += display_table(min_gcr, max_gcr, gcr_steps, min_tilt, max_tilt, tilt_steps, npv, db{"max_npv"}.npv, strategy);
		key = 'Max NPV';
		str += table_key(key);
		
		//Plot of NPV as a function of tilt angle (for various GCRs):
		yaxis_title = 'Net Present Value ($)';
		graph_title = 'Figure 2: Net Present Value';
		graph_name = 'max_npv';
		str += '<p style="text-align: center"><img src="'+new_plot(npv, clr, yaxis_title, graph_title, graph_name) + '" /></p>';
		
		
		//Max Energy Yield Results:
		str += '<br><br><h3  style="text-align: center">Results for Max Energy Yield: </h3>';
		str += display_results(db{"max_yield"}.gcr, db{"max_yield"}.tilt, db{"yield_config"}.nmodx, nmody, db{"yield_config"}.nrows, 
						db{"yield_config"}.row_spacing, db{"yield_config"}.total_modules, modules_per_string_yield, string_in_parallel_yield,
						inverter_yield, db{"max_yield"}.energy, db{"max_yield"}.system_size, db{"max_yield"}.npv, db{"max_yield"}.yield, db{"max_yield"}.lcoe);
		
		//Table for Energy Yield Results:
		strategy = false;	//checks if table is for fisplaying LCOE (which impacts number of significant digits to display on screen):
		str += '<br><p style="text-align: center"><strong>Table 3:</strong>Energy Yield at Specified Combinations of GCR and Tilt Angles (kWh/kW): </p>';
		str += display_table(min_gcr, max_gcr, gcr_steps, min_tilt, max_tilt, tilt_steps, yield, db{"max_yield"}.yield, strategy);
		key = 'Max Energy Yield';
		str += table_key(key);
		
		//Plot of energy yield as a function of tilt angle (for various GCRs):
		yaxis_title = 'Energy Yield (kWh/kW)';
		graph_title = 'Figure 3: Energy Yield';
		graph_name = 'max_yield';
		str += '<p style="text-align: center"><img src="'+new_plot(yield, clr, yaxis_title, graph_title, graph_name) + '" /></p>';
		
		
		if(finConfig !='Third Party'){	//Since LCOE is not calculated in TPO
			//Min LCOE Results:
			str += '<br><br><h3  style="text-align: center">Results for Min LCOE: </h3>';
			str += display_results(db{"min_lcoe"}.gcr, db{"min_lcoe"}.tilt, db{"lcoe_config"}.nmodx, nmody, db{"lcoe_config"}.nrows, 
							db{"lcoe_config"}.row_spacing, db{"lcoe_config"}.total_modules, modules_per_string_lcoe, string_in_parallel_lcoe,
							inverter_lcoe, db{"min_lcoe"}.energy, db{"min_lcoe"}.system_size, db{"min_lcoe"}.npv, db{"min_lcoe"}.yield, db{"min_lcoe"}.lcoe);
			
			//Table for LCOE Results:
			strategy = true;	//checks if table is for fisplaying LCOE (which impacts number of significant digits to display on screen):
			str += '<br><p style="text-align: center"><strong>Table 4:</strong> LCOE at Specified Combinations of GCR and Tilt Angles (in cents/kWh): </p>';
			str += display_table(min_gcr, max_gcr, gcr_steps, min_tilt, max_tilt, tilt_steps, lcoe, db{"min_lcoe"}.lcoe, strategy);
			key = 'Min LCOE';
			str += table_key(key);
			
			//Plot of LCOE as a function of tilt angle (for various GCRs):
			yaxis_title = 'Levelized Cost of Electricity(cents/kWh)';
			graph_title = 'Figure 4: Levelized Cost of Electricity';
			graph_name = 'min_lcoe';
			str += '<p style="text-align: center"><img src="'+new_plot(lcoe, clr, yaxis_title, graph_title, graph_name) + '" /></p>';
		}
		
		
		newplot(true);
		
		str += '</body></html>';
		if ( macro.show_in_browser == 'Yes' )
		{
			html_file = cwd() + '/' + active_case() + '_' + to_string(sub_number[0]) 
									+ to_string(sub_number[1]) + '_results' + '.html';
			write_text_file( html_file , str );
			browse( html_file );
		}
		else
			html_dialog(str, 'Optimal Array Layout', [1000,800]);

		subarray_to_optimize++;
		if(single_subarray == true) break;			//If user is optimizing only a single subarray, exit the while loop, i.e., end the macro at this point.
		
}

///////////////////////////////////**** End of Script ****///////////////////////////////////

outln('\n\t//////***** Simulation Complete *****//////');
if (update_results != 'Do Not Update')
			outln('\n\tSubarray configuration in active case has been updated with respect to the following strategy: ' + update_results);